### collectMetrics.R ###############################################################################
# Summarize fragments (number and median size) for REF and ALT reads and compare fragment size
# distribution using a KS test.

### collectMetrics #################################################################################
#' Summarize fragment size
#'
#' This function returns summary metrics, including counts and median fragment size, and attempts 
#' to classify the target variant as somatic, germline or non-somatic.
#'
#' @param fragment.data list containing annotated fragment data generated by annotateReads
#' @param target data.frame containing target mutation (see formatTargets)
#' @param verbose logical indicating whether or not to print metrics to screen (default = TRUE)
#' @return data.frame of summary metrics 
#' @examples
#' test.maf.file <- system.file('extdata', 'test_snp_data.maf', package = 'CompareFragmentSize'); 
#' test.bam.file <- system.file('extdata', 'sample1_example.bam', package = 'CompareFragmentSize'); 
#' mutations <- formatTargets(input = test.maf.file, id = 'Sample1');
#' target.reads <- getReadsFromBAM(filePath = test.bam.file, targets = mutations[1,]);
#' fragment.data <- annotateReads(ga = target.reads, targets = mutations[1,]);
#' summary.metrics <- collectMetrics(fragment.data, mutations[1,]);
#' @export
collectMetrics <- function(fragment.data, target, alpha = 0.01, verbose = TRUE) {

	if ('list' != class(fragment.data)) {
		stop('fragment.data should be a list output by annotateReads.');
	} else if (!'annotated' %in% names(fragment.data)) {
		stop('fragment.data should be a list output by annotateReads.');
	} else {
		fragments <- fragment.data$annotated;
	}

	# count and summarize insert size per allele 
	variant <- paste(target[1,c('Chromosome','Start','REF','ALT')], collapse = '_');

	ref.fragments <- fragments[which(fragments$Group == 'REF')];
	alt.fragments <- fragments[which(fragments$Group == 'ALT')];

	if (verbose) {
		print(paste('For variant: ', variant));
		print(paste('N reference reads: ', length(ref.fragments)));
		print(paste('N variant reads: ', length(alt.fragments)));
		print(aggregate(isize ~ Allele, fragments, median));
		if ('FS' %in% colnames(GenomicRanges::mcols(fragments))) {
			print(aggregate(FS ~ Allele, fragments, median));
			}
		}

	output.data <- target[1,];
	output.data[,c('Count_WT','Count_VAR','Median_WT','Median_VAR','VAF','KS.p','Classification')] <- NA;
	if ('FS' %in% colnames(GenomicRanges::mcols(fragments))) {
		output.data[,c('WTFS','VFS','ttest.p')] <- NA;
		}

	# summarize fragment sizes
	if (length(ref.fragments) > 0) {
		output.data$Count_WT <- length(ref.fragments);
		output.data$Median_WT <- median(ref.fragments$isize);
		if ('FS' %in% colnames(GenomicRanges::mcols(fragments))) {
			output.data$WTFS <- median(ref.fragments$FS);
			}
		}

	if (length(alt.fragments) > 0) {
		output.data$Count_VAR <- length(alt.fragments);
		output.data$Median_VAR <- median(alt.fragments$isize);
		if ('FS' %in% colnames(GenomicRanges::mcols(fragments))) {
			output.data$VFS <- median(alt.fragments$FS);
			}
		}

	if ( (length(ref.fragments) > 0) & (length(alt.fragments) > 0) ){
		output.data$VAF <- output.data$Count_VAR / 
			sum(output.data[,c('Count_WT','Count_VAR')]);

		output.data$KS.p <- ks.test(
			alt.fragments$isize,
			ref.fragments$isize,
			alternative = 'greater')$p.value;

		if ('FS' %in% colnames(GenomicRanges::mcols(fragments))) {
			output.data$ttest.p <- tryCatch(
				expr = t.test(
					alt.fragments$FS,
					ref.fragments$FS,
					alternative = 'greater')$p.value,
				error = function(e) { NA } 
				);
			}

		# indicate predicted classification for each variant (somatic [tumour-derived] or 
		#	non-somatic [CHIP/germline/sequencing artefact])
		output.data$KS.Class <- if (output.data$KS.p < alpha) { 'somatic';
			} else { 'non-somatic';
			}

		output.data$FS.Class <- if (output.data$ttest.p < alpha) { 'somatic';
			} else { 'non-somatic';
			}

		output.data$Classification <- if (output.data$KS.Class == output.data$FS.Class) {
			output.data$FS.Class } else { 'inconclusive' }

		if (verbose) {
			print(paste('Classification:', output.data$Classification[1]));
			}
		}

	return(output.data);
	}
